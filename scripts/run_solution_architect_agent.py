import os
import sys
from pathlib import Path

# Get the project root directory (parent of scripts folder)
project_root = Path(__file__).parent.parent
backend_dir = project_root / 'backend'

# Add both project root and backend to Python path
sys.path.extend([str(project_root), str(backend_dir)])

import asyncio
import json
from datetime import datetime
from typing import Dict, Any
import signal
from core.logging.logger import setup_logger
from core.tracing.service import trace_method, tracing_service
from memory.memory_manager import MemoryManager
from agents.solution_architect.sa_agent import SolutionArchitectAgent
from agents.solution_architect.sa_state_graph import create_initial_state
from backend.config import config
from agents.core.monitoring.service import monitoring_service

# Initialize logger
logger = setup_logger("run_solution_architect")

# Shared flag for shutdown
shutdown_event = asyncio.Event()

async def cleanup(signal_received=None):
    """Cleanup function to be called on shutdown."""
    if signal_received:
        logger.info(f'Received signal: {signal_received}')
    logger.info('Starting cleanup process...')
    
    try:
        await monitoring_service.cleanup()
        logger.info('Monitoring service cleanup completed')
    except Exception as e:
        logger.error(f"Error cleaning up monitoring service: {str(e)}", exc_info=True)

def signal_handler(signum, frame):
    """Signal handler that works on both Windows and Unix."""
    logger.info(f'Signal received: {signum}')
    # Set the event
    if asyncio.get_event_loop().is_running():
        asyncio.get_event_loop().create_task(cleanup(signum))
    shutdown_event.set()

@trace_method
async def run_solution_architect(project_description: str, project_plan: Dict[str, Any]) -> Dict[str, Any]:
    """
    Run the Solution Architect Agent.
    
    Args:
        project_description: Project description
        project_plan: Project plan generated by Project Manager Agent
        
    Returns:
        Dict[str, Any]: Solution architecture with specifications
    """
    memory_manager = None
    solution_architect = None
    
    try:
        # Initialize Memory Manager
        memory_manager = await MemoryManager.create(config.database_url())
        logger.info("Memory Manager initialized")

        # Initialize Solution Architect Agent
        agent_id = f"sa_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        solution_architect = SolutionArchitectAgent(
            agent_id=agent_id,
            name="Solution Architect",
            memory_manager=memory_manager
        )
        logger.info(f"Solution Architect Agent initialized with ID: {agent_id}")

        # Create initial state
        initial_state = create_initial_state(project_description, project_plan)
        logger.info("Created initial state")
        
        async with solution_architect:
            # Run the agent
            result = await solution_architect.run({
                "input": project_description,
                "project_plan": project_plan
            })
            
            if not result:
                raise ValueError("Solution Architect execution produced no result")
                
            logger.info("Solution Architect execution completed")
            
            report = await solution_architect.generate_report()
            logger.info("Generated final report")

            return result

    except Exception as e:
        logger.error(f"Error running Solution Architect: {str(e)}", exc_info=True)
        raise
    
    finally:
        if solution_architect:
            try:
                await cleanup()
            except Exception as e:
                logger.error(f"Error during monitoring cleanup: {str(e)}", exc_info=True)
                
        if memory_manager:
            try:
                await memory_manager.cleanup()
                logger.info("Memory manager cleanup completed")
            except Exception as e:
                logger.error(f"Error during memory cleanup: {str(e)}", exc_info=True)

@trace_method
async def main():
    try:
        # Setup signal handlers in a cross-platform way
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)

        # Sample project description and plan
        project_description = """
        Create a web application for task management with the following features:
        - User authentication
        - Task creation and assignment
        - Project organization
        - Progress tracking
        - Team collaboration
        """
        
        # Sample project plan from Project Manager
        project_plan = {
            "milestones": [
                {
                    "name": "User Authentication System",
                    "tasks": [
                        {"id": "1", "name": "Implement user registration", "dependencies": [], "effort": "MEDIUM"},
                        {"id": "2", "name": "Implement login functionality", "dependencies": ["1"], "effort": "MEDIUM"},
                        {"id": "3", "name": "Implement password reset", "dependencies": ["2"], "effort": "LOW"}
                    ]
                },
                {
                    "name": "Task Management",
                    "tasks": [
                        {"id": "4", "name": "Implement task creation", "dependencies": ["2"], "effort": "MEDIUM"},
                        {"id": "5", "name": "Implement task assignment", "dependencies": ["4"], "effort": "LOW"},
                        {"id": "6", "name": "Implement task status updates", "dependencies": ["4"], "effort": "LOW"}
                    ]
                },
                {
                    "name": "Project Organization",
                    "tasks": [
                        {"id": "7", "name": "Implement project creation", "dependencies": ["2"], "effort": "MEDIUM"},
                        {"id": "8", "name": "Implement task grouping by project", "dependencies": ["4", "7"], "effort": "MEDIUM"}
                    ]
                },
                {
                    "name": "Team Collaboration",
                    "tasks": [
                        {"id": "9", "name": "Implement team creation", "dependencies": ["2"], "effort": "MEDIUM"},
                        {"id": "10", "name": "Implement team member management", "dependencies": ["9"], "effort": "MEDIUM"},
                        {"id": "11", "name": "Implement permissions system", "dependencies": ["9", "10"], "effort": "HIGH"}
                    ]
                }
            ],
            "resource_allocation": {
                "Solution Architect": ["1", "2", "7", "9"],
                "Full Stack Developer": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"],
                "QA/Test Agent": ["3", "6", "8", "11"]
            },
            "timeline_options": [
                {"configuration": "1 Full Stack Developer", "total_duration": 50},
                {"configuration": "2 Full Stack Developers", "total_duration": 30}
            ]
        }

        result = await run_solution_architect(project_description, project_plan)
        
        if result:
            print("\nFinal Solution Architecture:")
            try:
                print(json.dumps(result, indent=2))
            except TypeError as e:
                logger.error(f"Error serializing result: {str(e)}")
                print("Raw result:", result)
        else:
            print("No result received from solution architect")
            
    except Exception as e:
        print(f"Error: {str(e)}")
        logger.error("Main execution failed", exc_info=True)
        await cleanup()
    finally:
        await cleanup()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Process interrupted by user")
    except Exception as e:
        logger.error(f"Process terminated with error: {str(e)}", exc_info=True)